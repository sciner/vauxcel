import { Bounds } from '../../../../scene/container/bounds/Bounds';
import { uid } from '../../../../utils/data/uid';
import { EventEmitter } from '../../../../utils/event_emitter';
import { Buffer } from '../buffer/Buffer';
import { BufferUsage } from '../buffer/const.js';
import { Attribute, type AttributeOption, ensureIsAttribute } from './Attribute';
import { ensureIsBuffer } from './utils/ensureIsBuffer';
import { getAttributeInfoFromFormat } from './utils/getAttributeInfoFromFormat';
import { getGeometryBounds } from './utils/getGeometryBounds';

import type { GeometryPerGL } from '../../gl/geometry/GlGeometrySystem';
import type { AttributeBaseCallbackStruct } from '../../gl/geometry/utils/generateAttributeSync';
import type { TypedArray } from '../buffer/Buffer';
import type { Topology } from './const';

export type IndexBufferArray = Uint16Array | Uint32Array;

/**
 * the interface that describes the structure of the geometry
 * @memberof rendering
 */
export interface GeometryDescriptor
{
    /** an optional label to easily identify the geometry */
    label?: string;
    /** the attributes that make up the geometry */
    attributes: Record<string, AttributeOption>;
    vertexBuffer?: Buffer | TypedArray | number[];
    /** optional index buffer for this geometry */
    indexBuffer?: Buffer | TypedArray | number[];
    /** the topology of the geometry, defaults to 'triangle-list' */
    topology?: Topology;
    proto?: Geometry;

    instanced?: boolean;
    strideFloats?: number;
    instanceCount?: number;
    vertexPerInstance?: number;
    indexPerInstance?: number;

}

/**
 * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.
 * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.
 * Essentially, a Geometry object holds the data you'd send to a GPU buffer.
 *
 * A geometry is basically made of two components:
 * <br>
 * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,
 * texture coordinates, etc. They map directly to attributes in your vertex shaders.
 * <br>
 * <b>Indices</b>: An optional array that describes how the vertices are connected.
 * If not provided, vertices will be interpreted in the sequence they're given.
 * @example
 *
 * const geometry = new Geometry({
 *   attributes: {
 *     aPosition: [ // add some positions
 *       0, 0,
 *       0, 100,
 *       100, 100,
 *       100,   0,
 *     ],
 *     aUv: [ // add some uvs
 *       0, 0,
 *       0, 1,
 *       1, 1,
 *       1, 0,
 *     ]
 *   }
 * });
 * @memberof rendering
 * @class
 */
export class Geometry extends EventEmitter<{
    update: Geometry,
    destroy: Geometry,
}>
{
    /** The topology of the geometry. */
    public topology: Topology;
    public proto: Geometry;
    /** The unique id of the geometry. */
    public readonly uid: number = uid('geometry');
    /** A record of the attributes of the geometry. */
    public attributes: Record<string, Attribute>;
    /** The buffers that the attributes use */
    public buffers: Buffer[];
    public bufferStride: Array<number>;
    public vertexBuffer: Buffer = null;
    /** The index buffer of the geometry */
    public indexBuffer: Buffer;
    /** Whether the geometry is instanced. */
    public instanced: boolean;

    /**
     * the layout key will be generated by WebGPU all geometries that have the same structure
     * will have the same layout key. This is used to cache the pipeline layout
     * @internal
     * @ignore
     */
    public _layoutKey = 0;

    /** the instance count of the geometry to draw */
    public instanceCount = 1;

    private readonly _bounds: Bounds = new Bounds();
    private _boundsDirty = true;

    constructor(options: GeometryDescriptor = { attributes: {} })
    {
        super();

        this.instanceCount = options.instanceCount || 1;

        if (options.vertexBuffer)
        {
            this.vertexBuffer = ensureIsBuffer(options.vertexBuffer, false);
        }
        if (options.indexBuffer)
        {
            this.indexBuffer = ensureIsBuffer(options.indexBuffer, true);
        }

        if (options.proto)
        {
            this.initFromProto(options);
        }
        else
        {
            this.initFromAttributes(options);
        }
    }

    private initFromProto(options: GeometryDescriptor)
    {
        const proto = this.proto = options.proto;

        this.buffers = proto.buffers.slice(0);
        this.bufferStride = proto.bufferStride.slice(0);
        this.attributes = proto.attributes;
        this.topology = options.topology || proto.topology;
        this.instanced = proto.instanced;
        this.vertexPerInstance = proto.vertexPerInstance;
        this.indexPerInstance = proto.indexPerInstance;
        this.strideFloats = proto.strideFloats;
        this.stride = proto.stride;

        if (this.vertexBuffer)
        {
            this.buffers[0] = this.vertexBuffer;
        }
        if (this.indexBuffer)
        {
            const ind = this.buffers.indexOf(proto.indexBuffer);

            if (ind >= 0)
            {
                this.buffers[ind] = this.indexBuffer;
            }
            else
            {
                this.buffers.push(this.indexBuffer);
            }
        }
        for (const i in options.attributes)
        {
            const attr = options.attributes[i];

            if (this.attributes[i])
            {
                const buf_ind = this.attributes[i].buffer_index;

                if (attr instanceof Buffer)
                {
                    this.buffers[buf_ind] = attr;

                    // attr.on('update', this.onBufferUpdate, this);
                    // attr.on('change', this.onBufferUpdate, this);
                }
            }
            else
            {
                // WTF
            }
        }
    }

    private initFromAttributes(options: GeometryDescriptor)
    {
        this.buffers = [];
        this.bufferStride = [];
        this.topology = options.topology || 'triangle-list';
        this.vertexPerInstance = options.vertexPerInstance || 3;
        this.indexPerInstance = options.indexPerInstance || 0;
        this.strideFloats = options.strideFloats || 0;

        if (this.vertexBuffer)
        {
            this.buffers[0] = this.vertexBuffer;
            this.bufferStride[0] = 0;
        }

        this.attributes = {};
        this.instanced = false;
        for (const i in options.attributes)
        {
            this.attributes[i] = new Attribute(ensureIsAttribute(options.attributes[i], this.vertexBuffer, options.instanced));
        }

        this.checkAttributes();

        if (this.indexBuffer)
        {
            this.buffers.push(this.indexBuffer);
        }
    }

    private checkAttributes()
    {
        const buffers = this.buffers;
        const attributes = this.attributes;
        const bufferStride = this.bufferStride;

        for (const j in attributes)
        {
            const attr = attributes[j];
            let buf_index = attr.buffer_index = this.buffers.indexOf(attr.buffer);

            this.instanced = attr.instance || this.instanced;

            if (buf_index === -1)
            {
                buf_index = attr.buffer_index = this.buffers.length;
                buffers.push(attr.buffer);
                bufferStride[buf_index] = 0;
                // two events here - one for a resize (new buffer change)
                // and one for an update (existing buffer change)
                // attribute.buffer.on('update', this.onBufferUpdate, this);
                // attribute.buffer.on('change', this.onBufferUpdate, this);
            }

            const attr_info = getAttributeInfoFromFormat(attributes[j].format);

            if (attr.offset === undefined)
            {
                attr.offset = bufferStride[buf_index];
            }

            bufferStride[buf_index] = Math.max(bufferStride[buf_index], attr.offset + attr_info.stride);
        }

        if (this.vertexBuffer)
        {
            const vpi = this.instanced ? 1 : this.vertexPerInstance;

            if (this.strideFloats)
            {
                this.bufferStride[0] = this.strideFloats / vpi * 4;
            }
            else
            {
                this.strideFloats = this.bufferStride[0] * vpi / 4;
            }
        }

        for (const j in attributes)
        {
            const attribute = attributes[j];

            if (attribute.stride === undefined)
            {
                attribute.stride = bufferStride[attribute.buffer_index];
            }
        }
        this.stride = this.strideFloats * 4;
    }

    protected onBufferUpdate(): void
    {
        this._boundsDirty = true;
        this.emit('update', this);
    }

    /**
     * Returns the requested attribute.
     * @param id - The name of the attribute required
     * @returns - The attribute requested.
     */
    public getAttribute(id: string): Attribute
    {
        return this.attributes[id];
    }

    /**
     * Returns the index buffer
     * @returns - The index buffer.
     */
    public getIndex(): Buffer
    {
        return this.indexBuffer;
    }

    /**
     * Returns the requested buffer.
     * @param id - The name of the buffer required.
     * @returns - The buffer requested.
     */
    public getBuffer(id: string): Buffer
    {
        return this.getAttribute(id).buffer;
    }

    /**
     * Used to figure out how many vertices there are in this geometry
     * @returns the number of vertices in the geometry
     */
    public getSize(): number
    {
        for (const i in this.attributes)
        {
            const attribute = this.attributes[i];
            const buffer = this.buffers[attribute.buffer_index];

            if (buffer.data)
            {
                return ((buffer.data as any).length) / (attribute.stride / 4);
            }

            return buffer.descriptor.size;
        }

        return 0;
    }

    /** Returns the bounds of the geometry. */
    get bounds(): Bounds
    {
        if (!this._boundsDirty) return this._bounds;

        this._boundsDirty = false;

        return getGeometryBounds(this, 'aPosition', this._bounds);
    }

    /**
     * destroys the geometry.
     * @param destroyBuffers - destroy the buffers associated with this geometry
     */
    public destroy(destroyBuffers = false): void
    {
        this.emit('destroy', this);

        this.removeAllListeners();

        this.removeBufferRef();

        if (destroyBuffers)
        {
            this.buffers.forEach((buffer) => buffer.destroy());
        }

        (this.attributes as null) = null;
        (this.buffers as null) = null;
        (this.indexBuffer as null) = null;
        (this._bounds as null) = null;
    }

    /**
     * in case instance is virtual
     * those are params for multidraw
     */
    public vertexPerInstance = 1;
    public indexPerInstance = 1;
    public strideFloats = 0;
    public stride = 0;

    glData: GeometryPerGL = null;
    bufRefCount: number = 0;
    _glAttributeBaseCallback: AttributeBaseCallbackStruct;

    addBufferRef()
    {
        if (this.bufRefCount > 0)
        {
            return;
        }

        this.bufRefCount++;

        const { buffers } = this;

        for (let i = 0; i < buffers.length; i++)
        {
            const buffer = buffers[i];

            buffer.refCount++;
        }
    }

    removeBufferRef()
    {
        const { buffers } = this;

        if (this.bufRefCount === 0)
        {
            return;
        }

        for (let i = 0; i < buffers.length; i++)
        {
            const buffer = buffers[i];

            buffer.refCount -= this.bufRefCount;
        }

        this.bufRefCount = 0;
    }

    swapBuffer(ind: number, newBuffer: Buffer)
    {
        const { buffers } = this;

        if (!buffers[ind])
        {
            throw new Error('buffer not found');
        }
        this.removeBufferRef();
        if (this.vertexBuffer === this.buffers[ind])
        {
            this.vertexBuffer = newBuffer;
        }
        else if (this.indexBuffer === this.buffers[ind])
        {
            this.indexBuffer = newBuffer;
        }
        this.buffers[ind] = newBuffer;
        this.emit('update', this);
    }

    swapIndex(newBuffer: Buffer)
    {
        if (this.bufRefCount > 0)
        {
            return;
        }

        let ind = -1;

        if (this.indexBuffer)
        {
            ind = this.buffers.indexOf(this.indexBuffer);
        }
        else if ((this.buffers.at(-1)?.descriptor.usage & BufferUsage.INDEX))
        {
            ind = this.buffers.length - 1;
        }

        if (ind < 0)
        {
            return;
        }

        this.buffers[ind] = this.indexBuffer = newBuffer;
    }

    getInstancedAttributes()
    {
        const instAttribs: Attribute[] = [];

        for (const i in this.attributes)
        {
            const attr = this.attributes[i];

            if (attr.instance)
            {
                instAttribs.push(attr);
            }
        }

        return instAttribs;
    }

    getInstancedAttributeNames()
    {
        const instAttribs: string[] = [];

        for (const i in this.attributes)
        {
            const attr = this.attributes[i];

            if (attr.instance)
            {
                instAttribs.push(i);
            }
        }

        return instAttribs;
    }

    /**
     * if buffer is used in instanced attribs, returns 1
     * otherwise, returns number of vertices per instance
     * @param buf_ind
     */
    getVertexPerInstance(buf_ind: number)
    {
        if (this.vertexPerInstance === 1)
        {
            return 1;
        }
        for (const key in this.attributes)
        {
            if (this.attributes[key].buffer_index === buf_ind)
            {
                if (!this.attributes[key].instance)
                {
                    return this.vertexPerInstance;
                }
            }
        }

        return 1;
    }

    getInstanceBufferStride(bufInd: number)
    {
        return this.bufferStride[bufInd] * this.getVertexPerInstance(bufInd);
    }
}
